/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Zip
 #	author : miyako
 #	2016/03/08
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

//#define zipOpenNewFileInZip3_64_noAES zipOpenNewFileInZip3_64
//#define zipOpenNewFileInZip64_noAES zipOpenNewFileInZip64
//#define zipWriteInFileInZip_noAES zipWriteInFileInZip
//#define zipCloseFileInZip_noAES zipCloseFileInZip

#define YIELD_FACTOR 0x2000

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Zip

		case 1 :
			Unzip(pResult, pParams);
			break;

		case 2 :
			Zip(pResult, pParams);
			break;

	}
}

#pragma mark -

#if VERSIONMAC
void convertPathToCodepage(std::string &path, UInt32 codepage)
{
	CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(codepage);
	if((encoding != kCFStringEncodingInvalidId) && CFStringIsEncodingAvailable(encoding))
	{
		NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault,
																												(const UInt8 *)path.c_str(),
																												path.length(),
																												kCFStringEncodingUTF8,
																												true);
		if(str)
		{
			uint32_t size = CFStringGetMaximumSizeForEncoding([str length], encoding) + sizeof(PA_Unichar);	//2 bytes for null termination
			std::vector<uint8_t> buf(size);
			CFIndex len = 0;
			CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), encoding, '?', false, (UInt8 *)&buf[0], size, &len);
			path = relative_path_t((char *)&buf[0], len);
			[str release];
		}
	}
}
#else
void convertPathToCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang)
{
	if(mlang)
	{
		C_TEXT tempUstr;
		UINT len, mlen, ulen;
		DWORD mode = 0;
		tempUstr.setUTF8String((const uint8_t *)path.c_str(), path.length());
		ulen = -1;
		LPWSTR ustr = (LPWSTR)tempUstr.getUTF16StringPtr();
		mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, NULL, &mlen);
		len = mlen+2;
		std::vector<uint8_t> buf(len);
		if(S_OK == mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, (CHAR *)&buf[0], &mlen))
		{
			path = std::string((char *)&buf[0]);
		}
	}
}
#endif

#if VERSIONMAC
void convertPathFromCodepage(std::string &path, UInt32 codepage)
{
	CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(codepage);
	if((encoding != kCFStringEncodingInvalidId) && CFStringIsEncodingAvailable(encoding))
	{
		NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault,
																							(const UInt8 *)path.c_str(),
																							path.length(),
																							encoding,
																							true);
		if(str)
		{
			uint32_t size = CFStringGetMaximumSizeForEncoding([str length], kCFStringEncodingUTF8) + sizeof(PA_Unichar);	//2 bytes for null termination
			std::vector<uint8_t> buf(size);
			CFIndex len = 0;
			CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), kCFStringEncodingUTF8, '?', false, (UInt8 *)&buf[0], size, &len);
			path = std::string((char *)&buf[0], len);
			[str release];
		}
	}
}
#else
void convertPathFromCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang)
{
	if(mlang)
	{
		LPSTR mstr = (LPSTR)path.c_str();
		UINT mlen = -1;
		UINT ulen, len;
		DWORD mode = 0;
		mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, NULL, &ulen);
		len = ((ulen * 2) + 2);
		std::vector<uint8_t> buf(len);
		if(S_OK == mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, (WCHAR *)&buf[0], &ulen))
		{
			C_TEXT tempUstr;
			tempUstr.setUTF16String((const PA_Unichar *)&buf[0], ulen);
			CUTF8String tempStr;
			tempUstr.copyUTF8String(&tempStr);
			path = std::string((char *)tempStr.c_str());
		}
	}
}
#endif

#pragma mark -

// -------------------------------------- Zip -------------------------------------

void Unzip(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT Param4;
	C_TEXT Param5;
	C_LONGINT Param6;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);
	Param6.fromParamAtIndex(pParams, 6);
    
    //pass
    CUTF8String password;
    Param3.copyUTF8String(&password);
    
    //src, dst
#if VERSIONMAC
    CUTF8String input_path, output_path;
    Param1.copyPath(&input_path);
    Param2.copyPath(&output_path);
    const char *input = (const char*)input_path.c_str();
    const char *output = (const char*)output_path.c_str();
#else
    const wchar_t *input = (const wchar_t*)Param1.getUTF16StringPtr();
    const wchar_t *output = (const wchar_t*)Param2.getUTF16StringPtr();    
#endif  
    
    unsigned int flags = Param4.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC    
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;    
#endif

#if VERSIONWIN
	IMultiLanguage2 *mlang = NULL;
	CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
	DWORD codepage = 0;
#endif
	
    //callback
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param5.getUTF16StringPtr());
    bool abortedByCallbackMethod = false;
	
	int charset = Param6.getIntValue();
	
    unzFile hUnzip = unzOpen64(input);
    
    if (hUnzip){
        
        returnValue.setIntValue(1);
        
        unz_file_info64 fileInfo;
        unz_global_info64 globalInfo;
        unz64_file_pos filePos;
        
        double number_entry;
        
//        bool isCallbackActive = false;
					bool isCallbackActive = Param5.getUTF16Length();
			
//        if(methodId){
            if(unzGetGlobalInfo64(hUnzip, &globalInfo) == UNZ_OK){
                number_entry = globalInfo.number_entry;
//                isCallbackActive = true;
//            }
        }
        
        std::vector<uint8_t> szConFilename(PATH_MAX);
        
        relative_path_t relative_path;
        absolute_path_t sub_path, absolute_path;

#if VERSIONMAC
            NSFileManager *fm = [[NSFileManager alloc]init];
#endif  
			
#if VERSIONMAC
			std::vector<TextEncoding> _encodings;
			TextEncoding *encodings = NULL;
			TECSnifferObjectRef sniffer = NULL;
			int len = MAX_LENGTH_FOR_ENCODING_NAME;
			ItemCount charset_count, charset_num;
			ItemCount numTextEncodings;
			ItemCount maxErrs;
			ItemCount maxFeatures;
			ItemCount *numErrsArray;
			if(charset == CHARSET_AUTOMATIC)
			{
				if(!TECCountAvailableTextEncodings(&charset_count))
				{
					_encodings.resize(charset_count);
					encodings = &_encodings[0];
					TECGetAvailableTextEncodings(encodings, charset_count, &charset_num);
					TECCreateSniffer(&sniffer, encodings, charset_num);
				}
			}
#else
			ULONG numTextEncodings = 0;
			if(mlang)
			{
				ULONG charset_count, charset_celt = 32;//	number of codes page information to retrive at a time
				MIMECPINFO charset_infos[32];
				IEnumCodePage* codepages = NULL;
				mlang->EnumCodePages(MIMECONTF_VALID, 0, &codepages);
				if(codepages)
				{
					while(codepages->Next(charset_celt, charset_infos, &charset_count) == S_OK)
					{
						numTextEncodings += charset_count;
					}
					codepages->Release();
				}
			}
#endif
			unsigned int yield_counter = 0;
        do {
					
					yield_counter++;
					if((yield_counter % YIELD_FACTOR) == 0)
					{
						PA_YieldAbsolute();
					}
					
					
            if (unzGetCurrentFileInfo64(hUnzip, &fileInfo, (char *)&szConFilename[0], PATH_MAX, NULL, 0, NULL, 0) != UNZ_OK){
                returnValue.setIntValue(0);
                break;
            }
					
					
#if VERSIONWIN
						relative_path = relative_path_t((const char *)&szConFilename[0]);
						relative_path_t sub_path_utf8 = relative_path;
#else
						relative_path = absolute_path_t((const char *)&szConFilename[0]);
						sub_path = relative_path;
#endif
					
						if(charset == CHARSET_AUTOMATIC)
						{
#if VERSIONMAC
							if(sniffer)
							{
								numTextEncodings = charset_num;
								maxErrs = relative_path.size();
								maxFeatures = relative_path.size();
								std::vector<ItemCount> _numErrsArray(charset_count);
								numErrsArray = &_numErrsArray[0];
								std::vector<ItemCount> _numFeaturesArray(charset_count);
								ItemCount *numFeaturesArray = &_numFeaturesArray[0];
								if(!TECSniffTextEncoding(sniffer,
									(ConstTextPtr)relative_path.c_str(),
									(ByteCount)relative_path.size(),
									encodings,
									numTextEncodings,
									numErrsArray,
									maxErrs,
									numFeaturesArray,
									maxFeatures))
								{
									RegionCode actualRegion;
									TextEncoding actualEncoding;
									ByteCount length;
									TextEncoding unicode = CreateTextEncoding(kTextEncodingUnicodeDefault,
																														kTextEncodingDefaultVariant,
																														kUnicode16BitFormat);
									
									std::vector<char> buf(len);
									if(!GetTextEncodingName(
																					encodings[0],
																					kTextEncodingFullName,
																					0,
																					unicode,
																					len,
																					&length,
																					&actualRegion,
																					&actualEncoding,
																					(TextPtr)&buf[0]))
									{
										CFStringRef name = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar*)&buf[0], (length/2));
										if(name)
										{
											UInt32 codepage = TextEncodingNameToWindowsCodepage(name);
											if(codepage > 0)
											{
												convertPathFromCodepage(relative_path, codepage);
												convertPathFromCodepage(sub_path, codepage);
											}
											CFRelease(name);
										}
									}
								}
							}
#else
							if(mlang)
							{
								char *data = (char *)relative_path.c_str();
								size_t size = relative_path.size();
								int scores = numTextEncodings;
								std::vector<DetectEncodingInfo> encodings(scores);
								mlang->DetectInputCodepage(MLDETECTCP_NONE, 0, data, (INT *)&size, &encodings[0], &scores);
								INT confidence = 0;
								
								for(int i = 0; i < scores ; ++i)
								{
									if(encodings[i].nLangID != 0)
									{
										if(confidence < encodings[i].nConfidence){
											codepage = encodings[i].nCodePage;
										}
									}
								}
								if(codepage > 0)
								{
									convertPathFromCodepage(relative_path, codepage, mlang);
									convertPathFromCodepage(sub_path_utf8, codepage, mlang);
								}
							}
#endif
						}else if(charset > 0)
						{
#if VERSIONMAC
							convertPathFromCodepage(relative_path, charset);
							convertPathFromCodepage(sub_path, charset);
#else
							convertPathFromCodepage(relative_path, charset, mlang);
							convertPathFromCodepage(sub_path_utf8, charset, mlang);
#endif
						}
#if VERSIONWIN
					unescape_path(sub_path_utf8);
					utf8_to_wcs(sub_path_utf8, sub_path);
#endif
            absolute_path = output;
            absolute_path+= folder_separator + sub_path;
            
            //callback
            if(isCallbackActive){
                
                double compressed_size = fileInfo.compressed_size;
                double uncompressed_size = fileInfo.uncompressed_size;
                    
                if(unzGetFilePos64(hUnzip, &filePos) == UNZ_OK){
                
                    double num_of_file = filePos.num_of_file;

										if(methodId)
										{
											PA_Variable	params[6];
											params[0] = PA_CreateVariable(eVK_Unistring);
											params[1] = PA_CreateVariable(eVK_Unistring);
											params[2] = PA_CreateVariable(eVK_Real);
											params[3] = PA_CreateVariable(eVK_Real);
											params[4] = PA_CreateVariable(eVK_Real);
											params[5] = PA_CreateVariable(eVK_Real);
											
											C_TEXT tempUstr;
											tempUstr.setUTF8String((const uint8_t *)relative_path.c_str(), relative_path.length());
											PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
											PA_SetStringVariable(&params[0], &methodParam1);
											tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), absolute_path.length());
											PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
											PA_SetStringVariable(&params[1], &methodParam2);
											
											PA_SetRealVariable(&params[2], num_of_file);
											PA_SetRealVariable(&params[3], number_entry);
											PA_SetRealVariable(&params[4], compressed_size);
											PA_SetRealVariable(&params[5], uncompressed_size);
											
											PA_Variable result = PA_ExecuteMethodByID(methodId, params, 6);

											if(PA_GetVariableKind(result) == eVK_Boolean)
												abortedByCallbackMethod = PA_GetBooleanVariable(result);
											
										//	PA_DisposeUnistring(&methodParam1);
										//	PA_DisposeUnistring(&methodParam2);
											PA_ClearVariable(&params[0]);
											PA_ClearVariable(&params[1]);
											PA_ClearVariable(&params[2]);
											PA_ClearVariable(&params[3]);
											PA_ClearVariable(&params[4]);
											PA_ClearVariable(&params[5]);
											
										}
										else
										{
											PA_Variable	params[8];
											params[2] = PA_CreateVariable(eVK_Unistring);
											params[3] = PA_CreateVariable(eVK_Unistring);
											params[4] = PA_CreateVariable(eVK_Real);
											params[5] = PA_CreateVariable(eVK_Real);
											params[6] = PA_CreateVariable(eVK_Real);
											params[7] = PA_CreateVariable(eVK_Real);
											
											params[0] = PA_CreateVariable(eVK_Unistring);
											PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)Param5.getUTF16StringPtr());
											PA_SetStringVariable(&params[0], &_methodName);
											
											params[1] = PA_CreateVariable(eVK_Boolean);
											PA_SetBooleanVariable(&params[1], false);
											
											C_TEXT tempUstr;
											tempUstr.setUTF8String((const uint8_t *)relative_path.c_str(), relative_path.length());
											PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
											PA_SetStringVariable(&params[2], &methodParam1);
											tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), absolute_path.length());
											PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
											PA_SetStringVariable(&params[3], &methodParam2);
											
											PA_SetRealVariable(&params[4], num_of_file);
											PA_SetRealVariable(&params[5], number_entry);
											PA_SetRealVariable(&params[6], compressed_size);
											PA_SetRealVariable(&params[7], uncompressed_size);
											
											PA_ExecuteCommandByID(1007, params, 8);
											
											abortedByCallbackMethod = PA_GetBooleanVariable(params[1]);

											PA_ClearVariable(&params[0]);
											PA_ClearVariable(&params[1]);
											PA_ClearVariable(&params[2]);
											PA_ClearVariable(&params[3]);
											PA_ClearVariable(&params[4]);
											PA_ClearVariable(&params[5]);
											PA_ClearVariable(&params[6]);
											PA_ClearVariable(&params[7]);
										}
	
                }

            }

            if(relative_path.size() > 1){
                if( !ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos)){
                    
                    create_parent_folder(absolute_path);
                    
                    if(relative_path.at(relative_path.size() - 1) == folder_separator){
                    
                        create_folder(absolute_path);
                        
                    }

                    if(password.length()){
                        if(unzOpenCurrentFilePassword(hUnzip, (const char *)password.c_str()) != UNZ_OK){
                            returnValue.setIntValue(0);
                            break;
                        }  
                    }else{ 
                        if(unzOpenCurrentFile(hUnzip) != UNZ_OK){
                            returnValue.setIntValue(0);
                            break;
                        }
                    }
                    
                    bool symbolicLinkCreated = false;
#if VERSIONMAC                     
                    if(with_atttributes){
                    
                        if(((fileInfo.external_fa >> 16L) & 0xA000) == 0xA000){
                        
                            std::vector<char> buf(PATH_MAX);
                            int len = unzReadCurrentFile(hUnzip, &buf[0], PATH_MAX);
                            
                            if(len > 0){
                                NSString *destinationPath =[[NSString alloc]initWithBytes:&buf[0] length:len encoding:NSUTF8StringEncoding];
                                NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                                symbolicLinkCreated = [fm createSymbolicLinkAtPath:fullPath withDestinationPath:destinationPath error:nil];
                                [fullPath release];
                                [destinationPath release];
                            }                        
                        
                        }
                         
                    }
#endif 
                    if(!symbolicLinkCreated){
                        std::ofstream ofs(absolute_path.c_str(), std::ios::out|std::ios::binary);
                        
                        if(ofs.is_open()){
                            
                            std::vector<uint8_t> buf(BUFFER_SIZE);
                            std::streamsize size;
													
													unsigned int yield_counter = 0;
													
                            while ((size = unzReadCurrentFile(hUnzip, &buf[0], BUFFER_SIZE)) > 0){
															yield_counter++;
															if((yield_counter % YIELD_FACTOR) == 0)
															{
																PA_YieldAbsolute();
															}
															
                                ofs.write((const char *)&buf[0], size);
                            }
                            
                            ofs.close();
                            
                        }                    
                    
                    }
                    
#if VERSIONMAC  
                    if(with_atttributes){
                    
                        short permission = (fileInfo.external_fa >> 16L) & 0x01FF;
                        
                        if(permission){
                        
                            NSDictionary *itemAttributes = [NSDictionary
                                                            dictionaryWithObject:[NSNumber numberWithShort:permission]
                                                            forKey:NSFilePosixPermissions];
                            
                            NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                            [fm setAttributes:itemAttributes ofItemAtPath:fullPath error:nil];
                            [fullPath release];
                            
                        }

                    }                    
#endif 
                }   
                
            }

            unzCloseCurrentFile(hUnzip);
            
        } while (!abortedByCallbackMethod && (unzGoToNextFile(hUnzip) != UNZ_END_OF_LIST_OF_FILE));
 
#if VERSIONMAC
            [fm release];
#endif         

#if VERSIONMAC
			if(sniffer)
			{
				TECDisposeSniffer(sniffer);
			}
#endif
        unzClose(hUnzip);	
    }     
	
#if VERSIONWIN
		if(mlang)
		{
			mlang->Release();
		}
#endif
	
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }   
                            
	returnValue.setReturn(pResult);
}

#ifdef WIN32

using namespace std;

int wcs_to_utf8(wstring& wstr, string& str){
   
    int error = 0; 
    
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), NULL, 0, NULL, NULL);
    if(len){
        vector<char> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            str = string((const char *)&buf[0]);
        }
    }else{
        str = string((const char *)"");
        error = -1;
    }
    
    return error;   
    
}

int utf8_to_wcs(string& str, wstring& wstr)
{
   
    int error = 0; 
    
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), NULL, 0);
    if(len){
        vector<char> buf((len + 1) * sizeof(wchar_t));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), (LPWSTR)&buf[0], len)){
            wstr = wstring((const wchar_t *)&buf[0]);
        }
    }else{
        wstr = wstring((const wchar_t *)L"");
        error = -1;
    }
    
    return error;   
    
}

void unescape_path(string &path)
{
    wstring wpath;
    utf8_to_wcs(path, wpath);
    unescape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void escape_path(string &path)
{
    wstring wpath;
    utf8_to_wcs(path, wpath);
    escape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void unescape_path(wstring &path)
{
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '/')
            path.at(i) = L'\\';
}

void escape_path(wstring &path)
{
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '\\')
            path.at(i) = L'/';
}

void get_subpaths(wstring& path,
                  absolute_paths_t *absolute_paths,
                  relative_paths_t *relative_paths,
				  relative_path_t& folder_name,
                  bool ignore_dot,
                  bool without_enclosing_folder,
                  size_t absolutePathOffset = 0)
{
    
    WIN32_FIND_DATA find;	
    
    HANDLE h = FindFirstFile(path.c_str(), &find);
    
    absolute_path_t absolute_path;
    relative_path_t relative_path;

    if(h != INVALID_HANDLE_VALUE){
			
			unsigned int yield_counter = 0;
			
        do {
            
					yield_counter++;
					if((yield_counter % YIELD_FACTOR) == 0)
					{
						PA_YieldAbsolute();
					}
					
					
            wstring sub_path = find.cFileName;
            
            if((!wcscmp(sub_path.c_str(), L"..")) || (!wcscmp(sub_path.c_str(), L".")))
                continue;		
            
            if(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
                
                if(!absolutePathOffset){
                    //top level is folder
                    absolutePathOffset = path.size() - 1;

					wcs_to_utf8(sub_path + L"/", folder_name);	

                    if(!without_enclosing_folder){
                        absolute_paths->push_back(path);
                        relative_paths->push_back(folder_name);
                    }

                    get_subpaths(path + L"\\*", 
                                 absolute_paths, 		
                                 relative_paths,       
                                 folder_name,
                                 ignore_dot, 
                                 without_enclosing_folder,
                                 absolutePathOffset);
                    
                }else{
                    //is sub-folder
                    absolute_path = path + sub_path; 
                    
                    wstring base_path = path.substr(0, path.size() - 1).substr(absolutePathOffset + 2);
                    base_path += sub_path;
                    base_path += L"\\";
                    escape_path(base_path);
                    wcs_to_utf8(base_path, relative_path);
					relative_path = folder_name + relative_path;

                    if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == string::npos)){
                     
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                        
                        get_subpaths(path.substr(0, path.size() - 1)  + sub_path + L"\\*", 
                                     absolute_paths, 
                                     relative_paths, 
									 folder_name,
                                     ignore_dot,
                                     without_enclosing_folder,
                                     absolutePathOffset);
                        
                    }
  
                }
                
            }else{
                
                if(!absolutePathOffset){
                    // (over-ride ignore_dot, this is top level)
                    absolute_path = path;// + sub_path;  
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);

                    absolute_paths->push_back(absolute_path);
                    relative_paths->push_back(relative_path);
                    
                }else{
                    
					wstring base_path = path.substr(0, path.size() - 1);
                    absolute_path = base_path + sub_path;  
                    
                    sub_path = base_path.substr(absolutePathOffset + 2) + sub_path;
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
					relative_path = folder_name + relative_path;

                    if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == string::npos)){
                        
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                    }
  
                }
                
            }		
            
        } while (FindNextFile(h, &find));
        /*
		if(!absolute_paths->size() && absolutePathOffset){
			wstring base_path = path.substr(0, path.size() - 1);
			relative_paths->push_back(folder_name);	
                absolute_paths->push_back(base_path);
		}
        */
        FindClose(h);
        
    }    
    
}
#endif

void get_subpaths(C_TEXT& Param, 
                  relative_paths_t *relative_paths, 
                  absolute_paths_t *absolute_paths, 
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder){
    
    relative_paths->clear();
    absolute_paths->clear();
    
#if VERSIONMAC
    
    std::string spath;
    copy_path(Param, spath);
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, spath.c_str());	
    
    //semantically the same string but the result from subpathsOfDirectoryAtPath is wrong if we use this:
    //NSString *path = Param.copyPath();
    
    NSFileManager *fm = [[NSFileManager alloc]init];
    
    BOOL isDirectory = YES;
    
    if(with_atttributes){
    
        NSDictionary *attributes = [fm attributesOfItemAtPath:path error:nil];
        
        if(attributes){
            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink] 
            || [[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular]){
                
                //over-ride ignore_dot, this is top level
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
                
            }else
            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory]){
            
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                NSString *folderPath = [path stringByDeletingLastPathComponent];
                if(![[folderPath substringFromIndex:[folderPath length]]isEqualToString:@"/"]){
                    folderPath = [folderPath stringByAppendingString:@"/"];
                }
                
                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES]; 
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                    basePath = [basePath stringByAppendingString:@"/"];
                }
                
                if(!without_enclosing_folder){
                    relative_paths->push_back([folderName UTF8String]);	
                    absolute_paths->push_back([basePath UTF8String]);
                }
                                
                NSDirectoryEnumerator *dirEnum = [fm enumeratorAtURL:baseUrl 
                includingPropertiesForKeys:[NSArray arrayWithObjects:NSURLIsDirectoryKey, NSURLIsHiddenKey, nil]
                options:0
                errorHandler:nil];
							unsigned int yield_counter = 0;
                while(NSURL *u = [dirEnum nextObject]){
                
									yield_counter++;
									if((yield_counter % YIELD_FACTOR) == 0)
									{
										PA_YieldAbsolute();
									}
                    
                    NSNumber *isDirectory;
                    [u getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:nil];
                    
                    NSNumber *isHidden;
                    [u getResourceValue:&isHidden forKey:NSURLIsHiddenKey error:nil];
                    
                    NSString *fullPath = [u path];

                    if([isDirectory boolValue])
                            fullPath = [fullPath stringByAppendingString:@"/"];
                       
                    absolute_path_t absolute_path = [fullPath UTF8String];
                    relative_path_t relative_path = [[fullPath substringFromIndex:[folderPath length]]UTF8String];
                    
                    if(!ignore_dot || (((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos) && ![isHidden boolValue])){
                    
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);	
                        }else{
                            relative_paths->push_back([[fullPath substringFromIndex:[basePath length]]UTF8String]);	
                        }
                    }
                } 
            }
        }//attributes
        
    }else{
    
        if([fm fileExistsAtPath:path isDirectory:&isDirectory]){
            
            if(isDirectory){
                
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];

                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES]; 
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                    basePath = [basePath stringByAppendingString:@"/"];
                }

                NSArray *paths = (NSMutableArray *)[fm subpathsOfDirectoryAtPath:path error:NULL];
                
                if(!without_enclosing_folder){
                    relative_paths->push_back([folderName UTF8String]);	
                    absolute_paths->push_back([basePath UTF8String]);
                }
                
                //a folder with contents

                for(NSUInteger i = 0; i < [paths count]; i++){
                    
									
									if((i % YIELD_FACTOR) == 0)
									{
										PA_YieldAbsolute();
									}
									
                    NSString *itemPath = [paths objectAtIndex:i];   
                    NSString *itemFullPath = [path stringByAppendingPathComponent:itemPath];  
                    
                    if([fm fileExistsAtPath:itemFullPath isDirectory:&isDirectory]){
                        
                        if(isDirectory)
                            itemPath = [itemPath stringByAppendingString:@"/"];
                        
                        absolute_path_t absolute_path = [itemFullPath UTF8String];
                        relative_path_t relative_path = [[folderName stringByAppendingString:itemPath]UTF8String];
                        
                        if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos)){
                        
                            	
                            absolute_paths->push_back(absolute_path);
                            
                            if(!without_enclosing_folder){
                                relative_paths->push_back(relative_path);	
                            }else{
                                relative_paths->push_back([itemPath UTF8String]);	
                            }
                        }
                    }				    
                }
                
            }else{	
                //a file (over-ride ignore_dot, this is top level)
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
            }
            
        }    
            
    }
    
    [path release];	
    [fm release];	
    
#else
    
    std::wstring path = std::wstring((wchar_t *)Param.getUTF16StringPtr());
    
	if(path.length()){
		if(path.substr(path.length() - 1) == L"\\"){
			path = path.substr(0, path.length() - 1);
		}		
	}
    
	relative_path_t folder_name;
    get_subpaths(path, absolute_paths, relative_paths, folder_name, ignore_dot, without_enclosing_folder);
    
#endif	
}

unsigned long getFileCrc(absolute_path_t &absolute_path)
{
	unsigned long CRC = crc32(0L, Z_NULL, 0);
	std::ifstream ifs_crc(absolute_path.c_str(), std::ios::in|std::ios::binary);
	if(ifs_crc.is_open())
	{
			std::vector<uint8_t> buf(BUFFER_SIZE);
		unsigned int yield_counter = 0;
			while(ifs_crc.good())
			{
				yield_counter++;
				if((yield_counter % YIELD_FACTOR) == 0)
				{
					PA_YieldAbsolute();
				}
					ifs_crc.read((char *)&buf[0], BUFFER_SIZE);
					CRC = crc32(CRC, (const Bytef *)&buf[0], ifs_crc.gcount());
			}
			ifs_crc.close();
	}
	return CRC;
}

void Zip(sLONG_PTR *pResult, PackagePtr pParams)
{

    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_TEXT Param6;
		C_LONGINT Param7;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);//src
    Param2.fromParamAtIndex(pParams, 2);//dst
    Param3.fromParamAtIndex(pParams, 3);//pass
    Param4.fromParamAtIndex(pParams, 4);//level
    Param5.fromParamAtIndex(pParams, 5);//options
    Param6.fromParamAtIndex(pParams, 6);//callback
    Param7.fromParamAtIndex(pParams, 7);//codepage
	
    //src
    absolute_paths_t absolute_paths;
    relative_paths_t relative_paths;
    relative_path_t input_file_name;
    
    //pass
    CUTF8String password;
    Param3.copyUTF8String(&password);
    
    //dst
#if VERSIONMAC    
    CUTF8String output_path;
    Param2.copyPath(&output_path);
    const char *output = (const char*)output_path.c_str();
#else
    const wchar_t *output = (const wchar_t*)Param2.getUTF16StringPtr();
#endif  
    
    //level
    unsigned int level = Param4.getIntValue();
    if(!level){
        level = Z_DEFAULT_COMPRESSION; 
    }else if (level > 10){
        level = 9;
    }
    
    unsigned int flags = Param5.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC    
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;    
#endif

    bool without_enclosing_folder = !!(flags & 4L);
    bool with_encyption = !!(flags & 8L);
	
#if VERSIONWIN
	IMultiLanguage2 *mlang = NULL;
	CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
#endif
	
    //callback
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param6.getUTF16StringPtr());
    bool abortedByCallbackMethod = false;
	
		int charset = Param7.getIntValue();
	
		get_subpaths(Param1, &relative_paths, &absolute_paths, ignore_dot, with_atttributes, without_enclosing_folder);

    if(relative_paths.size()){
        
        unsigned long CRC; 
        
        zipFile hZip = zipOpen64(output, APPEND_STATUS_CREATE);
        
        if(hZip){
            
            returnValue.setIntValue(1);
            
            zip_fileinfo zi;
            
            time_t currentTime;
            time(&currentTime);
            
            struct tm *tm;
            tm=localtime(&currentTime);
            
            zi.tmz_date.tm_sec=tm->tm_sec;
            zi.tmz_date.tm_min=tm->tm_min;
            zi.tmz_date.tm_hour=tm->tm_hour;
            zi.tmz_date.tm_mday=tm->tm_mday;
            zi.tmz_date.tm_mon=tm->tm_mon;
            zi.tmz_date.tm_year=tm->tm_year;            
            zi.external_fa = 0;
            zi.internal_fa = 0;
            zi.dosDate = 0;
               
            double number_entry;
               
//            bool isCallbackActive = false;
							bool isCallbackActive = Param6.getUTF16Length();
					
//            if(methodId){
                    number_entry = relative_paths.size();
//                    isCallbackActive = true; 
//            }
							
#if VERSIONMAC
            NSFileManager *fm = [[NSFileManager alloc]init];
#endif                       

						std::vector<uint8_t> buf(BUFFER_SIZE);
					
            for (unsigned int i = 0; i < relative_paths.size(); ++i) {
							
							if((i % YIELD_FACTOR) == 0)
							{
								PA_YieldAbsolute();
							}
							
                relative_path_t relative_path = relative_paths.at(i);
                absolute_path_t absolute_path = absolute_paths.at(i);
								relative_path_t relative_path_utf8 = relative_path;
							
								if(charset > 0)
								{
#if VERSIONMAC
									convertPathToCodepage(relative_path, charset);
#else
									convertPathToCodepage(relative_path, charset, mlang);
#endif
								}
							
                zi.external_fa = 0;
#if VERSIONMAC  

                    if(with_atttributes){
                    
                        NSDictionary *attributes = [fm attributesOfItemAtPath:[NSString stringWithUTF8String:(const char *)absolute_path.c_str()]error:nil];
                        
                        if(attributes){
                             
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeCharacterSpecial]){
                                zi.external_fa = 0x20000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory]){
                                zi.external_fa = 0x40000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeBlockSpecial]){
                                zi.external_fa = 0x60000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular]){
                                zi.external_fa = 0x80000000;
                            }else
                            if(([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink])){
                                zi.external_fa = 0xA0000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSocket]){
                                zi.external_fa = 0xC0000000;
                            }

													zi.external_fa |= ([[attributes valueForKey:NSFilePosixPermissions]shortValue] << 16L);

                        }//attributes 
                        
                    }//with_atttributes
#endif                
                
                //callback
                if(isCallbackActive){
									
									
									if(methodId)
									{
										PA_Variable	params[4];
										params[0] = PA_CreateVariable(eVK_Unistring);
										params[1] = PA_CreateVariable(eVK_Unistring);
										params[2] = PA_CreateVariable(eVK_Real);
										params[3] = PA_CreateVariable(eVK_Real);
										
										C_TEXT tempUstr;
										tempUstr.setUTF8String((const uint8_t *)relative_path_utf8.c_str(), relative_path_utf8.length());
										PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
										PA_SetStringVariable(&params[0], &methodParam1);
										tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), absolute_path.length());
										PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
										PA_SetStringVariable(&params[1], &methodParam2);
										
										PA_SetRealVariable(&params[2], i+1);
										PA_SetRealVariable(&params[3], number_entry);
										
										PA_Variable result = PA_ExecuteMethodByID(methodId, params, 4);
										
										if(PA_GetVariableKind(result) == eVK_Boolean)
											abortedByCallbackMethod = PA_GetBooleanVariable(result);
										
										PA_ClearVariable(&params[0]);
										PA_ClearVariable(&params[1]);
										PA_ClearVariable(&params[2]);
										PA_ClearVariable(&params[3]);
										
									}else
									{
										PA_Variable	params[6];
										
										params[2] = PA_CreateVariable(eVK_Unistring);
										params[3] = PA_CreateVariable(eVK_Unistring);
										params[4] = PA_CreateVariable(eVK_Real);
										params[5] = PA_CreateVariable(eVK_Real);
										
										params[0] = PA_CreateVariable(eVK_Unistring);
										PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)Param6.getUTF16StringPtr());
										PA_SetStringVariable(&params[0], &_methodName);
										
										params[1] = PA_CreateVariable(eVK_Boolean);
										PA_SetBooleanVariable(&params[1], false);
										
										C_TEXT tempUstr;
										tempUstr.setUTF8String((const uint8_t *)relative_path_utf8.c_str(), relative_path_utf8.length());
										PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
										PA_SetStringVariable(&params[2], &methodParam1);
										tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), absolute_path.length());
										PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
										PA_SetStringVariable(&params[3], &methodParam2);
										
										PA_SetRealVariable(&params[4], i+1);
										PA_SetRealVariable(&params[5], number_entry);
										
										PA_ExecuteCommandByID(1007, params, 6);
										
										abortedByCallbackMethod = PA_GetBooleanVariable(params[1]);
										
										PA_ClearVariable(&params[0]);
										PA_ClearVariable(&params[1]);
										PA_ClearVariable(&params[3]);
										PA_ClearVariable(&params[4]);
										PA_ClearVariable(&params[5]);
									}
	
                }
							
                if(abortedByCallbackMethod){
                    i = number_entry;
                }

								if (with_encyption)
								{
									CRC = getFileCrc(absolute_path);
									if(zipOpenNewFileInZip3_64(hZip,
																						 relative_path.c_str(),
																						 &zi,
																						 NULL, 0,
																						 NULL, 0,
																						 NULL,
																						 Z_DEFLATED,
																						 level,
																						 0, -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
																						 (password.length() ? (const char *)password.c_str() : NULL), CRC, 1) != 0){
											returnValue.setIntValue(0);
											break;
									}
								}else{
									if(password.length())
									{
										CRC = getFileCrc(absolute_path);

										if(zipOpenNewFileInZip3_64_noAES(hZip,
																							 relative_path.c_str(),
																							 &zi,
																							 NULL, 0,
																							 NULL, 0,
																							 NULL,
																							 Z_DEFLATED,
																							 level,
																							 0, -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
																							 (password.length() ? (const char *)password.c_str() : NULL), CRC, 1) != 0){
												returnValue.setIntValue(0);
												break;
										}
									}else{
                    if(zipOpenNewFileInZip64_noAES(hZip,
                                             relative_path.c_str(),
                                             &zi,
                                             NULL, 0,
                                             NULL, 0,
                                             NULL,
                                             Z_DEFLATED,
                                             level,
                                             0) != 0){
                        returnValue.setIntValue(0);
                        break;
                    }
									}
								}

                bool isSymbolicLink = false;
                
#if VERSIONMAC
                if(with_atttributes){
                    NSString *symbolicPath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
                    NSString *destinationPath = [fm destinationOfSymbolicLinkAtPath:symbolicPath error:nil];
                    if(destinationPath){
                        std::string destinationPath_utf8([destinationPath UTF8String]);
												if (with_encyption){
													zipWriteInFileInZip(hZip, (char *)destinationPath_utf8.c_str(), destinationPath_utf8.size());
												}else{
													zipWriteInFileInZip_noAES(hZip, (char *)destinationPath_utf8.c_str(), destinationPath_utf8.size());
												}
                        [symbolicPath release];
                        isSymbolicLink = TRUE;
                    }  
                }
#endif                

                if(!isSymbolicLink){
                
                    std::ifstream ifs(absolute_path.c_str(), std::ios::in|std::ios::binary);
                
                    if(ifs.is_open()){
											unsigned int yield_counter = 0;
                        while(ifs.good()){
													yield_counter++;
													if((yield_counter % YIELD_FACTOR) == 0)
													{
														PA_YieldAbsolute();
													}
                            ifs.read((char *)&buf[0], BUFFER_SIZE);
														if (with_encyption){
															zipWriteInFileInZip(hZip, (char *)&buf[0], ifs.gcount());
														}else{
															zipWriteInFileInZip_noAES(hZip, (char *)&buf[0], ifs.gcount());
														}
                        }
                        
                        ifs.close();
                        
                    }
                
                }
								if (with_encyption)
								{
									zipCloseFileInZip(hZip);
								}else{
									zipCloseFileInZip_noAES(hZip);
								}
            }
#if VERSIONMAC
            [fm release];
#endif             
            zipClose(hZip, NULL);
            
        }        
        
    }
	
#if VERSIONWIN
		if(mlang)
		{
			mlang->Release();
		}
#endif
	
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }      
        
    returnValue.setReturn(pResult);
}

#pragma mark -

bool create_folder(absolute_path_t& absolute_path){
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path 
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];	
    [path release];					
    [fm release];			
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path.c_str());				
#endif	
    
    return success;
}

void create_parent_folder(absolute_path_t& absolute_path){
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder(folderPath);
    [filePath release];
#else	
    wchar_t	fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path.c_str(), fDrive, fDir, fName, fExt);	
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder(folderPath);
#endif	
}

void copy_path(C_TEXT& t, absolute_path_t& p){
#if VERSIONMAC	
    NSString *str = t.copyUTF16String();
    NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
    
    if(u){
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
        CFIndex size = CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)path);
        std::vector<uint8_t> buf(size);		
        [path getFileSystemRepresentation:(char *)&buf[0] maxLength:size];
        p = std::string((char *)&buf[0]);
        [path release];
        [u release];
    }	
    
    [str release];
    
#else
    p = std::wstring((wchar_t *)t.getUTF16StringPtr());
    
    if(p.at(p.size() - 1) == L'\\')
        p = p.substr(0, p.size() - 1);
#endif	
}
